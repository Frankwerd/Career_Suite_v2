/**
 * Project: Automated Job Application Tracker & Pipeline Manager v2.0
 * Author: Francis John LiButti
 * Version: 2.0.0 (Based on Chrono v8 - Full Integration)
 * Last Updated: May 12, 2024 // <-- USER: Update this date
 *
 * Description: This Google Apps Script streamlines your job application workflow by
 * automatically parsing details from Gmail, logging to a Google Sheet, managing
 * labels, setting up triggers, and flagging stale applications.
 * It supports a fixed Spreadsheet ID or dynamic sheet creation/finding.
 *
 * Required Scopes (Comprehensive):
 * - https://www.googleapis.com/auth/spreadsheets
 * - https://www.googleapis.com/auth/gmail.labels
 * - https://www.googleapis.com/auth/gmail.readonly (or .modify)
 * - https://www.googleapis.com/auth/drive.file (If FIXED_SPREADSHEET_ID is not used/placeholder)
 * - https://www.googleapis.com/auth/script.storage (If dynamic sheet ID is used)
 * - https://www.googleapis.com/auth/script.scriptapp (For creating triggers)
 * - https://www.googleapis.com/auth/script.external_request
 */

// --- Configuration ---
const DEBUG_MODE = false;

// -- Spreadsheet Configuration --
const FIXED_SPREADSHEET_ID = ""; // <--- PASTE REAL ID or leave placeholder for dynamic
const TARGET_SPREADSHEET_FILENAME = "Assisted Job Application Tracker Data"; // For dynamic sheet creation
const SPREADSHEET_ID_PROPERTY_KEY = 'jobAppTrackerSheetId_v8_FullHybrid'; // For dynamic sheet ID storage
const SHEET_TAB_NAME = "Applications"; // Used by all sheet operations

// -- Gmail Label Configuration --
const GMAIL_LABEL_PARENT = "Assisted Job Application Tracker";
const GMAIL_LABEL_TO_PROCESS = GMAIL_LABEL_PARENT + "/To Process";
const GMAIL_LABEL_APPLIED_AFTER_PROCESSING = GMAIL_LABEL_PARENT + "/Processed";
const GMAIL_LABEL_MANUAL_REVIEW = GMAIL_LABEL_PARENT + "/Manual Review Needed";

// --- Column Indices ---
const PROCESSED_TIMESTAMP_COL = 1; const EMAIL_DATE_COL = 2; const PLATFORM_COL = 3; const COMPANY_COL = 4; const JOB_TITLE_COL = 5; const STATUS_COL = 6; const LAST_UPDATE_DATE_COL = 7; const EMAIL_SUBJECT_COL = 8; const EMAIL_LINK_COL = 9; const EMAIL_ID_COL = 10;
const TOTAL_COLUMNS_IN_SHEET = 10;

// --- Status Values ---
const DEFAULT_STATUS = "Applied"; const REJECTED_STATUS = "Rejected"; const ACCEPTED_STATUS = "Offer/Accepted"; const INTERVIEW_STATUS = "Interview Scheduled"; const ASSESSMENT_STATUS = "Assessment/Screening"; const MANUAL_REVIEW_NEEDED = "N/A - Manual Review Needed"; const DEFAULT_PLATFORM = "Other";

// --- Config for Auto-Reject Stale Apps ---
const WEEKS_THRESHOLD = 7;
const FINAL_STATUSES_FOR_STALE_CHECK = new Set([ REJECTED_STATUS, ACCEPTED_STATUS, "Withdrawn", INTERVIEW_STATUS, ASSESSMENT_STATUS ]);

// Keywords (Use your full lists!)
const REJECTION_KEYWORDS = [ "unfortunately", "regret to inform", "not moving forward"]; // Example
const ACCEPTANCE_KEYWORDS = [ "pleased to offer", "offer of employment", "job offer"]; // Example
const INTERVIEW_KEYWORDS = [ "invitation to interview", "schedule an interview", "interview request"]; // Example
const ASSESSMENT_KEYWORDS = [ "assessment", "coding challenge", "online test"]; // Example
const PLATFORM_DOMAIN_KEYWORDS = { "linkedin": "LinkedIn", "indeed": "Indeed", "wellfound": "Wellfound"}; // Example
const IGNORED_DOMAINS = new Set([ 'greenhouse.io', 'lever.co', 'myworkday.com', 'gmail.com']); // Example


// --- Helper: Get or Create Gmail Label ---
function getOrCreateLabel(labelName) { if (!labelName || typeof labelName !== 'string' || labelName.trim() === "") { Logger.log(`[ERROR] Invalid labelName: "${labelName}"`); return null; } let label = null; try { label = GmailApp.getUserLabelByName(labelName); } catch (e) { Logger.log(`[ERROR] Check label "${labelName}": ${e}`); return null; } if (!label) { if (DEBUG_MODE) Logger.log(`[DEBUG] Creating label: "${labelName}"`); try { label = GmailApp.createLabel(labelName); Logger.log(`[INFO] Created label: "${labelName}"`); } catch (e) { Logger.log(`[ERROR] Create label "${labelName}": ${e}\n${e.stack}`); return null; } } else { if (DEBUG_MODE) Logger.log(`[DEBUG] Label "${labelName}" exists.`); } return label; }

// --- Helper: Setup Sheet Formatting ---
// --- Helper: Setup Sheet Formatting (Enhanced Version with Email Link Clip) ---
function setupSheetFormatting(sheet) {
  // Only apply full formatting if the sheet is completely empty
  if (sheet.getLastRow() === 0 && sheet.getLastColumn() === 0) {
     Logger.log(`[INFO] SETUP_SHEET: Sheet "${sheet.getName()}" is new/empty. Applying detailed formatting.`);

     // --- 1. Define Headers ---
     let headers = [];
     headers[PROCESSED_TIMESTAMP_COL - 1] = "Processed Timestamp"; headers[EMAIL_DATE_COL - 1] = "Email Date"; headers[PLATFORM_COL - 1] = "Platform"; headers[COMPANY_COL - 1] = "Company Name"; headers[JOB_TITLE_COL - 1] = "Job Title"; headers[STATUS_COL - 1] = "Status"; headers[LAST_UPDATE_DATE_COL - 1] = "Last Update Email Date"; headers[EMAIL_SUBJECT_COL - 1] = "Email Subject"; headers[EMAIL_LINK_COL - 1] = "Email Link"; headers[EMAIL_ID_COL - 1] = "Email ID";
     for (let i = 0; i < TOTAL_COLUMNS_IN_SHEET; i++) { if (!headers[i]) headers[i] = `Col ${i + 1}`; }
     sheet.appendRow(headers);

     // --- 2. Header Row Formatting ---
     const headerRange = sheet.getRange(1, 1, 1, TOTAL_COLUMNS_IN_SHEET);
     headerRange.setFontWeight('bold').setHorizontalAlignment('center').setVerticalAlignment('middle');
     sheet.setRowHeight(1, 40);
     sheet.setFrozenRows(1); // Freeze Row 1
     Logger.log(`[INFO] SETUP_SHEET: Header styling (inc. frozen row) applied.`);

     // --- 3. Data Area Defaults (Wrapping for most, default height) ---
     // Apply to all potential data rows for default behavior
     const allDataRange = sheet.getRange(2, 1, sheet.getMaxRows() > 1 ? sheet.getMaxRows() - 1 : 1000, TOTAL_COLUMNS_IN_SHEET);
     allDataRange.setWrapStrategy(SpreadsheetApp.WrapStrategy.WRAP).setVerticalAlignment('top'); // Default wrap for all data
     if (sheet.getMaxRows() > 1) {
         try {
             // Set a default generous row height; rows can still expand with WRAP
             sheet.setRowHeightsForRange(allDataRange, 2, sheet.getMaxRows() > 1 ? sheet.getMaxRows() - 1 : 1000, 30);
         } catch (e) { Logger.log(`[WARN] Setup: Could not set default row heights: ${e}`);}
     }

     // --- 4. Specific Column Widths ---
     try {
       sheet.setColumnWidth(PROCESSED_TIMESTAMP_COL, 160);
       sheet.setColumnWidth(EMAIL_DATE_COL, 120);
       sheet.setColumnWidth(PLATFORM_COL, 120);
       sheet.setColumnWidth(COMPANY_COL, 200);
       sheet.setColumnWidth(JOB_TITLE_COL, 250);
       sheet.setColumnWidth(STATUS_COL, 130);
       sheet.setColumnWidth(LAST_UPDATE_DATE_COL, 160);
       sheet.setColumnWidth(EMAIL_SUBJECT_COL, 300);
       sheet.setColumnWidth(EMAIL_LINK_COL, 100); // Still set a width
       sheet.setColumnWidth(EMAIL_ID_COL, 200);
       Logger.log(`[INFO] SETUP_SHEET: Column widths applied.`);
     } catch (e) { Logger.log(`[WARN] Setup: Could not set column widths: ${e}`); }

     // --- 5. Set Specific Wrap Strategy for Email Link Column (CLIP) ---
     // This overrides the general WRAP set above for this specific column
     if (EMAIL_LINK_COL > 0 && TOTAL_COLUMNS_IN_SHEET >= EMAIL_LINK_COL) {
        try {
            const emailLinkColumnRange = sheet.getRange(2, EMAIL_LINK_COL, sheet.getMaxRows() > 1 ? sheet.getMaxRows() -1 : 1000, 1);
            emailLinkColumnRange.setWrapStrategy(SpreadsheetApp.WrapStrategy.CLIP);
            Logger.log(`[INFO] SETUP_SHEET: Set Email Link column (Col ${EMAIL_LINK_COL}) to CLIP.`);
        } catch(e) {
            Logger.log(`[WARN] SETUP_SHEET: Could not set Email Link column to CLIP. Error: ${e}`);
        }
     }


     // --- 6. Alternating Color Format (Banding) ---
     if (sheet.getMaxRows() > 1) {
        const bandingRange = sheet.getRange(2, 1, sheet.getMaxRows() - 1, TOTAL_COLUMNS_IN_SHEET);
        try {
            bandingRange.removeCheckboxes();
            const banding = bandingRange.applyRowBanding(SpreadsheetApp.BandingTheme.LIGHT_GREY);
            banding.setHeaderRowColor(null).setFirstRowColor("#E3F2FD").setSecondRowColor("#FFFFFF");
            Logger.log(`[INFO] SETUP_SHEET: Banding applied.`);
        } catch (e) { Logger.log(`[WARN] Setup: Could not apply banding: ${e}`); }
     }

     // --- 7. Hide Unused Columns ---
     const lastUsedColumn = TOTAL_COLUMNS_IN_SHEET;
     const maxColumnsInSheet = sheet.getMaxColumns();
     if (maxColumnsInSheet > lastUsedColumn) {
         try {
            sheet.hideColumns(lastUsedColumn + 1, maxColumnsInSheet - lastUsedColumn);
            Logger.log(`[INFO] SETUP_SHEET: Hid unused columns from ${String.fromCharCode(65 + lastUsedColumn)}.`);
         } catch(e) { Logger.log(`[WARN] Setup: Could not hide columns: ${e}`); }
     }
     Logger.log(`[INFO] SETUP_SHEET: Detailed formatting attempt complete.`);
  } else {
    if (DEBUG_MODE) Logger.log(`[DEBUG] SETUP_SHEET: Sheet "${sheet.getName()}" has content. Basic formatting (like frozen row) might be reapplied if missing.`);
    // Ensure row 1 is frozen even if sheet has content and full formatting is skipped
    if (sheet.getFrozenRows() < 1) {
        try {
            sheet.setFrozenRows(1);
            Logger.log(`[INFO] Ensured Row 1 is frozen on existing sheet "${sheet.getName()}".`);
        } catch (e) {
            Logger.log(`[WARN] Could not freeze row on existing sheet: ${e}`);
        }
     }
    // If the sheet has content, you might also want to specifically check and set the Email Link column to CLIP
    // This ensures it applies even if the sheet wasn't "new/empty" during setup.
    if (EMAIL_LINK_COL > 0 && TOTAL_COLUMNS_IN_SHEET >= EMAIL_LINK_COL && sheet.getLastRow() > 1) { // Check if there's data beyond header
        try {
            const emailLinkColumnDataRange = sheet.getRange(2, EMAIL_LINK_COL, sheet.getLastRow() -1 , 1); // Only apply to existing data rows
            if(emailLinkColumnDataRange.getWrapStrategies()[0][0] !== SpreadsheetApp.WrapStrategy.CLIP){ // Check current strategy before setting
                emailLinkColumnDataRange.setWrapStrategy(SpreadsheetApp.WrapStrategy.CLIP);
                Logger.log(`[INFO] SETUP_SHEET: Ensured Email Link column (Col ${EMAIL_LINK_COL}) is CLIP on existing sheet with content.`);
            }
        } catch(e) {
            Logger.log(`[WARN] SETUP_SHEET: Could not set Email Link column to CLIP on existing sheet with content. Error: ${e}`);
        }
     }
  }
}

// --- Helper: Get Sheet Access (Hybrid: Fixed ID or Dynamic Find/Create) ---
function getOrCreateSpreadsheetAndSheet() { let ss = null; let sheet = null; const properties = PropertiesService.getUserProperties(); if (FIXED_SPREADSHEET_ID && FIXED_SPREADSHEET_ID.trim() !== "" && FIXED_SPREADSHEET_ID !== "YOUR_SPREADSHEET_ID_HERE") { Logger.log(`[INFO] SPREADSHEET: Using Fixed ID: "${FIXED_SPREADSHEET_ID}"`); try { ss = SpreadsheetApp.openById(FIXED_SPREADSHEET_ID); Logger.log(`[INFO] SPREADSHEET: Opened "${ss.getName()}" (Fixed ID).`); } catch (e) { const msg = `FIXED ID FAIL: ID "${FIXED_SPREADSHEET_ID}". ${e.message}. Check ID/permissions. STOP.`; Logger.log(`[FATAL] ${msg}`); try { SpreadsheetApp.getUi().alert("Config Error (Fixed ID)", msg, SpreadsheetApp.getUi().ButtonSet.OK); } catch (uiErr) {} return { spreadsheet: null, sheet: null }; } } else { Logger.log(`[INFO] SPREADSHEET: Fixed ID not set. Dynamic find/create...`); const storedId = properties.getProperty(SPREADSHEET_ID_PROPERTY_KEY); if (storedId) { Logger.log(`[INFO] SPREADSHEET: Found stored ID: "${storedId}". Opening...`); try { ss = SpreadsheetApp.openById(storedId); Logger.log(`[INFO] SPREADSHEET: Opened "${ss.getName()}" (Stored ID).`); } catch (e) { Logger.log(`[WARN] SPREADSHEET: Stored ID "${storedId}" invalid (${e.message}). Removing.`); properties.deleteProperty(SPREADSHEET_ID_PROPERTY_KEY); ss = null; } } if (!ss) { Logger.log(`[INFO] SPREADSHEET: Searching Drive for "${TARGET_SPREADSHEET_FILENAME}"...`); try { const files = DriveApp.getFilesByName(TARGET_SPREADSHEET_FILENAME); if (files.hasNext()) { ss = SpreadsheetApp.open(files.next()); const fId = ss.getId(); properties.setProperty(SPREADSHEET_ID_PROPERTY_KEY, fId); Logger.log(`[INFO] SPREADSHEET: Found by name: "${ss.getName()}". Stored ID: ${fId}.`); if (files.hasNext()) Logger.log(`[WARN] Multiple files named "${TARGET_SPREADSHEET_FILENAME}".`); } else { Logger.log(`[INFO] SPREADSHEET: No file by name.`); } } catch (e) { Logger.log(`[ERROR] Drive search error: ${e.message}.`); } } if (!ss) { Logger.log(`[INFO] SPREADSHEET: Creating new: "${TARGET_SPREADSHEET_FILENAME}"...`); try { ss = SpreadsheetApp.create(TARGET_SPREADSHEET_FILENAME); const nId = ss.getId(); properties.setProperty(SPREADSHEET_ID_PROPERTY_KEY, nId); Logger.log(`[INFO] SPREADSHEET: Created "${ss.getName()}". Stored ID: ${nId}.`); } catch (e) { const msg = `CREATE FAIL: "${TARGET_SPREADSHEET_FILENAME}". ${e.message}`; Logger.log(`[FATAL] ${msg}`); try { SpreadsheetApp.getUi().alert("Create Error", msg, SpreadsheetApp.getUi().ButtonSet.OK); } catch (uiErr) {} return { spreadsheet: null, sheet: null }; } } } if (ss) { sheet = ss.getSheetByName(SHEET_TAB_NAME); if (!sheet) { Logger.log(`[INFO] TAB: "${SHEET_TAB_NAME}" not found. Creating...`); try { sheet = ss.insertSheet(SHEET_TAB_NAME); Logger.log(`[INFO] TAB: Created.`); const dSheet = ss.getSheetByName('Sheet1'); if (dSheet && dSheet.getName()!==SHEET_TAB_NAME && ss.getSheets().length > 1) { try { ss.deleteSheet(dSheet); Logger.log(`[INFO] Removed 'Sheet1'.`); } catch (e) {Logger.log(`[WARN] Failed remove 'Sheet1': ${e}`);}} } catch (e) { const msg = `TAB CREATE FAIL: "${SHEET_TAB_NAME}" in "${ss.getName()}". ${e.message}`; Logger.log(`[FATAL] ${msg}`); try {SpreadsheetApp.getUi().alert("Tab Error", msg, SpreadsheetApp.getUi().ButtonSet.OK);} catch (uiErr) {} return {spreadsheet: ss, sheet: null};}} else {Logger.log(`[INFO] TAB: Found existing "${SHEET_TAB_NAME}".`);} if (sheet) {setupSheetFormatting(sheet);}} else {Logger.log(`[FATAL] SPREADSHEET: 'ss' is null.`); return {spreadsheet:null,sheet:null};} return {spreadsheet:ss, sheet:sheet};}

// --- Trigger: Email Processing (Hourly) ---
function createTimeDrivenTrigger() { const funcName = 'processJobApplicationEmails'; let exists = false; ScriptApp.getProjectTriggers().forEach(t => { if (t.getHandlerFunction() === funcName && t.getEventType() === ScriptApp.EventType.CLOCK) { exists = true; }}); let msg = ""; if (!exists) { try { ScriptApp.newTrigger(funcName).timeBased().everyHours(1).create(); msg = `Hourly trigger for "${funcName}" created.`; Logger.log(`[INFO] TRIGGER: ${msg}`); } catch (e) { msg = `FAIL create hourly trigger for "${funcName}": ${e.message}`; Logger.log(`[ERROR] TRIGGER: ${msg}`); } } else { msg = `Hourly trigger for "${funcName}" already exists.`; Logger.log(`[INFO] TRIGGER: ${msg}`); } try { SpreadsheetApp.getUi().alert("Email Trigger Setup", msg, SpreadsheetApp.getUi().ButtonSet.OK); } catch (e) { Logger.log(`[WARN] UI Alert (Email Trigger): ${msg}`); } return !exists; }

// --- Trigger: Stale Reject (Daily) ---
function createOrVerifyStaleRejectTrigger() { const funcName = 'markStaleApplicationsAsRejected'; let exists = false; ScriptApp.getProjectTriggers().forEach(t => { if (t.getHandlerFunction() === funcName && t.getEventType() === ScriptApp.EventType.CLOCK) { exists = true; }}); let msg = ""; if (!exists) { try { ScriptApp.newTrigger(funcName).timeBased().everyDays(1).atHour(0).create(); msg = `Daily trigger for "${funcName}" (around midnight) created.`; Logger.log(`[INFO] TRIGGER: ${msg}`); } catch (e) { msg = `FAIL create daily trigger for "${funcName}": ${e.message}`; Logger.log(`[ERROR] TRIGGER: ${msg}`); } } else { msg = `Daily trigger for "${funcName}" already exists.`; Logger.log(`[INFO] TRIGGER: ${msg}`); } try { SpreadsheetApp.getUi().alert("Stale Reject Trigger Setup", msg, SpreadsheetApp.getUi().ButtonSet.OK); } catch (e) { Logger.log(`[WARN] UI Alert (Stale Trigger): ${msg}`); } return !exists; }

// --- Initial Setup Function ---
function initialSetup_LabelsAndSheet() { Logger.log(`\n==== STARTING INITIAL SETUP (LABELS, SHEET, TRIGGERS) ====`); let overallSuccess = true; let messages = []; Logger.log("[INFO] SETUP: Verifying/Creating Labels..."); const pL = getOrCreateLabel(GMAIL_LABEL_PARENT); Utilities.sleep(100); const tpL = getOrCreateLabel(GMAIL_LABEL_TO_PROCESS); Utilities.sleep(100); const dL = getOrCreateLabel(GMAIL_LABEL_APPLIED_AFTER_PROCESSING); Utilities.sleep(100); const mrL = getOrCreateLabel(GMAIL_LABEL_MANUAL_REVIEW); if (!pL||!tpL||!dL||!mrL) { messages.push(`Labels: FAIL (P:${!!pL},TP:${!!tpL},D:${!!dL},MR:${!!mrL})`); overallSuccess=false; } else { messages.push("Labels: OK."); } Logger.log("[INFO] SETUP: Verifying/Creating Sheet & Tab..."); const {spreadsheet:ss, sheet:sh} = getOrCreateSpreadsheetAndSheet(); if (!ss||!sh) { messages.push("Sheet/Tab: FAIL. Check logs."); overallSuccess=false; } else { messages.push(`Sheet/Tab: OK ("${ss.getName()}" / "${sh.getName()}").`); } Logger.log("[INFO] SETUP: Verifying/Creating Email Processor Trigger..."); createTimeDrivenTrigger(); messages.push("Email Trigger: Check separate log/alert for status (hourly)."); Logger.log("[INFO] SETUP: Verifying/Creating Stale Reject Trigger..."); createOrVerifyStaleRejectTrigger(); messages.push("Stale Reject Trigger: Check separate log/alert for status (daily ~midnight)."); const finalMsg = `Initial setup ${overallSuccess ? "completed." : "had issues."}\n\nDetails:\n- ${messages.join('\n- ')}`; Logger.log(`\n==== INITIAL SETUP ${overallSuccess ? "OK" : "ISSUES"} ====\n${finalMsg.replace(/\n- /g,'\n  - ')}`); try {SpreadsheetApp.getUi().alert( `Setup ${overallSuccess?"Complete":"Issues"}`, finalMsg, SpreadsheetApp.getUi().ButtonSet.OK); } catch(e){Logger.log(`UI Alert fail. Setup result: ${overallSuccess}`);} Logger.log("==== END INITIAL SETUP ===="); }

// --- Parsing & Core Logic (Your unmodified functions here) ---
function parseCompanyFromDomain(sender) { /* ... Your full code ... */  const emailMatch = sender.match(/<([^>]+)>/); if (!emailMatch || !emailMatch[1]) return null;  const emailAddress = emailMatch[1]; const domainParts = emailAddress.split('@'); if (domainParts.length !== 2) return null;  let domain = domainParts[1].toLowerCase();  if (IGNORED_DOMAINS.has(domain) && domain !== 'hi.wellfound.com') { return null; }  domain = domain.replace(/^(?:careers|jobs|recruiting|apply|hr|talent|notification|notifications)[^a-z0-9]/i, '');  domain = domain.replace(/[^a-z0-9]+(?:com|org|net|io|co|ai|dev|xyz|tech|ca|uk|de|fr|app|eu|us|info|biz)$/i, '');  domain = domain.replace(/[^a-z0-9]+/gi, ' ');  domain = domain.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');  return domain.trim() || null;}
function parseCompanyFromSenderName(sender) { /* ... Your full code ... */  const nameMatch = sender.match(/^"?(.*?)"?\s*</); let name = nameMatch ? nameMatch[1].trim() : sender.split('<')[0].trim();  if (!name || name.includes('@')) return null;  name = name.replace(/\|\s*(?:greenhouse|lever|wellfound|workday|ashby|icims|smartrecruiters|taleo|bamboohr)\b/i, '');  name = name.replace(/\s*(?:via Wellfound|via LinkedIn|via Indeed|from Greenhouse|from Lever)\b/gi, '');  name = name.replace(/\s*(?:Careers|Recruiting|Recruitment|Hiring Team|Hiring|Talent Acquisition|Talent|HR|Team|Notifications?|Jobs?|Updates?|Apply)\b/gi, '');  name = name.replace(/[|,-_.\s]+$/, '').trim();  if (name.length > 2 && !/^(?:noreply|no-reply|jobs|careers|support|info|admin|hr|talent|recruiting)$/i.test(name)) { return name; }  return null;}
function cleanHtmlText(htmlSnippet) { /* ... Your full code ... */  if (!htmlSnippet) return "";  let cleaned = htmlSnippet.replace(/ /g, ' ').replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>').replace(/"/g, '"').replace(/'/g, "'");  cleaned = cleaned.replace(/<[^>]*>/g, ' ');  cleaned = cleaned.replace(/\s+/g, ' ').trim();  return cleaned;}
function extractCompanyAndTitle(message, platform, emailSubject, plainBody) { /* ... Your full code ... */  let company = MANUAL_REVIEW_NEEDED;  let title = MANUAL_REVIEW_NEEDED;  let sender = message.getFrom();  if (DEBUG_MODE) Logger.log(`[DEBUG] PARSE_DETAIL: Starting Company/Title Extraction...`);  let tempCompanyFromDomain = null; let tempCompanyFromName = null;  try { tempCompanyFromDomain = parseCompanyFromDomain(sender); }  catch (e) { Logger.log(`[WARN] Error during initial company domain parsing: ${e}`); }  try { tempCompanyFromName = parseCompanyFromSenderName(sender); }  catch (e) { Logger.log(`[WARN] Error during initial company sender name parsing: ${e}`); }  if (platform === "Wellfound") {    if (DEBUG_MODE) Logger.log("[DEBUG] PARSE_DETAIL: Running Wellfound specific parsing logic...");    try {        if (plainBody) {            let wfCoSub = emailSubject.match(/update from (.*?)(?: \||$)/i) || emailSubject.match(/application to (.*?)(?: successfully|$)/i);            let wfCoBody = null;            const bodyLinesWF = plainBody.substring(0, 600).split('\n');            const companyHeaderIndexWF = bodyLinesWF.findIndex(l => /^[A-Z][A-Za-z\s.&'-]+$/.test(l.trim()) && l.trim().length > 1 && l.trim().split(' ').length < 5);            if (companyHeaderIndexWF !== -1) wfCoBody = bodyLinesWF[companyHeaderIndexWF].trim();            if (wfCoSub && wfCoSub[1]) { company = wfCoSub[1].trim(); if (DEBUG_MODE) Logger.log(`[DEBUG]  -> Wellfound Subject Parse Success (Company): "${company}"`); }            else if (wfCoBody) { company = wfCoBody; if (DEBUG_MODE) Logger.log(`[DEBUG]  -> Wellfound Body Header Parse Success (Company): "${company}"`); }            if (companyHeaderIndexWF !== -1 && company !== MANUAL_REVIEW_NEEDED) {                 for (let j = companyHeaderIndexWF + 1; j < Math.min(companyHeaderIndexWF + 4, bodyLinesWF.length); j++) {                     const potentialTitle = bodyLinesWF[j].trim();                     if (potentialTitle && !/[$]|\d{5,}|remote|hybrid|onsite|location:/i.test(potentialTitle) && /[a-zA-Z]{3,}/.test(potentialTitle)) {                         title = potentialTitle; if (DEBUG_MODE) Logger.log(`[DEBUG]  -> Wellfound Body Parse Success (Title near header): "${title}"`); break;                     }                 }             }         } else { Logger.log("[WARN] PARSE_DETAIL: Plain body was null/unavailable for Wellfound parsing."); }         if (title === MANUAL_REVIEW_NEEDED && sender.toLowerCase().includes("team@hi.wellfound.com")) {              if (DEBUG_MODE) Logger.log("[DEBUG] PARSE_DETAIL: Wellfound title still needed, trying PLAIN TEXT '* pattern' scan...");             try {                 if (plainBody) {                    const lines = plainBody.split('\n');                    const markerPhrase = "if there's a match, we will make an email introduction.";                    const markerIndex = lines.findIndex(line => line.replace(/=\d{2}/g, '').trim().toLowerCase().includes(markerPhrase.toLowerCase()));                    if (markerIndex !== -1) {                        for (let i = markerIndex + 1; i < lines.length; i++) {                            const currentLine = lines[i].replace(/=\d{2}/g, '').trim();                            if (currentLine.startsWith('* ')) {                                 const potentialTitle = currentLine.substring(2).trim();                                if (potentialTitle) { title = potentialTitle; Logger.log(`[INFO] PARSE_DETAIL: Extracted Wellfound title from plain text '* ' pattern: "${title}"`); break; }                            } else if (currentLine.length > 0 && !currentLine.match(/^[\s\*\-=–—]+$/)) { if (DEBUG_MODE) Logger.log(`[DEBUG] Found significant non-empty line before finding '* '. Stopping '*' scan.`); break; }                         }                        if (title === MANUAL_REVIEW_NEEDED && DEBUG_MODE) { Logger.log("[DEBUG]  -> Scanned lines after marker phrase, did not find '* ' title."); }                     } else if (DEBUG_MODE) { Logger.log("[DEBUG]  -> Marker phrase for '*' scan not found."); }                 } else { Logger.log("[WARN]  -> Plain text body was null/unavailable for '*' scan."); }              } catch (e) { Logger.log(`[ERROR] During Wellfound plain text '* ' title parsing: ${e}`); }         }    } catch (e) { Logger.log(`[ERROR] During Wellfound specific platform parsing block: ${e}`); }  }   if (company === MANUAL_REVIEW_NEEDED) {     let simpleSubjectMatch = emailSubject.match(/applying to ([^-:\|]+)/i) || emailSubject.match(/interest in ([^-:\|]+)/i) || emailSubject.match(/update from ([^-:\|]+)/i) || emailSubject.match(/^([\w\s.&'-]+)\s*[|–—:]/);     if (simpleSubjectMatch && simpleSubjectMatch[1]) { company = simpleSubjectMatch[1].trim(); if (DEBUG_MODE) Logger.log(`[DEBUG] PARSE_DETAIL: Found Company using Simple Subject Regex: "${company}"`); }  }   if (company === MANUAL_REVIEW_NEEDED || title === MANUAL_REVIEW_NEEDED) {     const complexPatterns = [ { r: /Invite.*?interview.*?for\s+(.+?)(?:\s+at\s+([^-:]+))?/i, titleIdx: 1, companyIdx: 2 }, { r: /Invite.*?interview.*?[-–—:]\s*(.+?)(?:\s+at\s+([^-:]+))?/i, titleIdx: 1, companyIdx: 2 }, { r: /Application for\s+(.+?)(?:\s*[-–—:]\s*(.+))?/i, titleIdx: 1, companyIdx: 2 }, { r: /applying to\s+(.+?)\s+at\s+([^-:]+)/i, titleIdx: 1, companyIdx: 2 }, { r: /interest in the\s+(.+?)\s+role(?:\s+at\s+([^-:]+))?/i, titleIdx: 1, companyIdx: 2 }, { r: /update on your\s+(.+?)\s+app(?:lication)?(?:\s+at\s+(.+))?/i, titleIdx: 1, companyIdx: 2 }, { r: /update on your\s+(.+?)\s+app(?:lication)?/i, titleIdx: 1, companyIdx: -1 }, { r: /Next Steps:.*?for\s+(.+?)\s+App(?:lication)?/i, titleIdx: 1, companyIdx: -1 } ];     try {        for (const patternInfo of complexPatterns) {            let match = emailSubject.match(patternInfo.r);            if (match) {                if (DEBUG_MODE) Logger.log(`[DEBUG]  -> Complex Subject Regex matched: ${patternInfo.r}`);                if (patternInfo.titleIdx > 0 && match[patternInfo.titleIdx] && title === MANUAL_REVIEW_NEEDED) { title = match[patternInfo.titleIdx].trim(); if (DEBUG_MODE) Logger.log(`[DEBUG]     -> Extracted Title: "${title}"`); }                if (patternInfo.companyIdx > 0 && match[patternInfo.companyIdx] && company === MANUAL_REVIEW_NEEDED) { company = match[patternInfo.companyIdx].trim(); if (DEBUG_MODE) Logger.log(`[DEBUG]     -> Extracted Company: "${company}"`); }                if (company !== MANUAL_REVIEW_NEEDED && title !== MANUAL_REVIEW_NEEDED) break;            }        }    } catch (e) { Logger.log(`[ERROR] During Complex Subject Regex processing: ${e}`); }  }   if (company === MANUAL_REVIEW_NEEDED || title === MANUAL_REVIEW_NEEDED) {    if (DEBUG_MODE) Logger.log("[DEBUG] PARSE_DETAIL: Attempting Body Scan Fallback...");    try {         if (plainBody) {            const bodyStart = plainBody.substring(0, 750);            if (company === MANUAL_REVIEW_NEEDED) { let bodyCompanyMatch = bodyStart.match(/applying to [^.]+ at ([A-Z][^.,\(\n]+)[.,\s\n]/i) || bodyStart.match(/application with ([A-Z][^.,\(\n]+)[.,\s\n]/i) || bodyStart.match(/interest in ([A-Z][^.,\(\n]+)[\s.,\n\(]/i); if (bodyCompanyMatch && bodyCompanyMatch[1]) { company = bodyCompanyMatch[1].trim(); if (DEBUG_MODE) Logger.log(`[DEBUG]  -> Found Company via Body Scan: "${company}"`); } }            if (title === MANUAL_REVIEW_NEEDED) { let bodyTitleMatch = bodyStart.match(/app(?:lication)? for the ([^.,\(\n]+?)\s*(?:position|role|opening)/i) || bodyStart.match(/interest in the ([^.,\(\n]+?)\s*(?:position|role|opening)/i) || bodyStart.match(/(?:position|role) of ([^.,\(\n]+?)(?: at |[\.,\n]|\s+with)/i) || bodyStart.match(/Thank you for applying for the\s+([^.,\n]+)\./i); if (bodyTitleMatch && bodyTitleMatch[1]) { title = bodyTitleMatch[1].trim().replace(/JR\d+\s*[-–—]?\s*/i, '').replace(/[\("].*?[\)"]/, '').replace(/^- /, '').trim(); if (DEBUG_MODE) Logger.log(`[DEBUG]  -> Found Title via Body Scan: "${title}"`); } }        } else { Logger.log("[WARN] PARSE_DETAIL: Plain body was null/unavailable for Body Scan fallback."); }    } catch (e) { Logger.log(`[ERROR] During Plain Body Scan fallback: ${e}`); }  }   if (company === MANUAL_REVIEW_NEEDED) {     if (DEBUG_MODE) Logger.log("[DEBUG] PARSE_DETAIL: Company still not found, attempting final fallback...");    if (tempCompanyFromName) { company = tempCompanyFromName; if (DEBUG_MODE) Logger.log(`[DEBUG]  -> Using Fallback Company from Sender Name: "${company}"`); }    else if (tempCompanyFromDomain) { company = tempCompanyFromDomain; if (DEBUG_MODE) Logger.log(`[DEBUG]  -> Using Fallback Company from Sender Domain: "${company}"`); }    else { if (DEBUG_MODE) Logger.log("[DEBUG]  -> Fallback failed: No valid pre-parsed company name."); }  }   if (company !== MANUAL_REVIEW_NEEDED) { try { company = company.split(/[\n\r#(]/)[0].replace(/ (?:inc|llc|ltd|corp|gmbh)[\.,]?$/i, '').replace(/[,"']?$/, '').trim(); if (!company) company = MANUAL_REVIEW_NEEDED; } catch (e) { Logger.log(`[WARN] Error during final Company name cleaning: ${e}`); company = MANUAL_REVIEW_NEEDED; } }   if (title !== MANUAL_REVIEW_NEEDED) { try { title = title.replace(/JR\d+\s*[-–—]?\s*/i, '').replace(/\(.*?(?:remote|hybrid|onsite|contract).*?\)/gi, '').replace(/[-–—]\s*(?:remote|hybrid|onsite|contract)\s*$/gi, '').replace(/[\n\r]/g, ' ').replace(/\s+/g, ' ').replace(/[,\.]*$/, '').trim(); if (!title) title = MANUAL_REVIEW_NEEDED; } catch (e) { Logger.log(`[WARN] Error during final Title cleaning: ${e}`); title = MANUAL_REVIEW_NEEDED; } }  Logger.log(`[INFO] PARSE_DETAIL: --- Final Extraction Result --- Company: "${company}", Title: "${title}"`);  return { company: company, title: title };}
function parseBodyForStatus(plainBody) { /* ... Your full code ... */  if (!plainBody || plainBody.length < 10) { if (DEBUG_MODE) Logger.log("[DEBUG] Skipping status check - plain body too short or missing."); return null; }  let bodyLower = plainBody.toLowerCase();  bodyLower = bodyLower.replace(/[.,!?;:()\[\]{}'"“”‘’\-–—]/g, ' ');  bodyLower = bodyLower.replace(/\s+/g, ' ').trim();   if (ACCEPTANCE_KEYWORDS.some(keyword => bodyLower.includes(keyword))) { if (DEBUG_MODE) Logger.log(`[DEBUG] STATUS_PARSE: Found ACCEPTANCE keyword.`); return ACCEPTED_STATUS; }  if (INTERVIEW_KEYWORDS.some(keyword => bodyLower.includes(keyword))) { if (DEBUG_MODE) Logger.log(`[DEBUG] STATUS_PARSE: Found INTERVIEW keyword.`); return INTERVIEW_STATUS; }  if (ASSESSMENT_KEYWORDS.some(keyword => bodyLower.includes(keyword))) { if (DEBUG_MODE) Logger.log(`[DEBUG] STATUS_PARSE: Found ASSESSMENT keyword.`); return ASSESSMENT_STATUS; }  if (REJECTION_KEYWORDS.some(keyword => bodyLower.includes(keyword))) { if (DEBUG_MODE) Logger.log(`[DEBUG] STATUS_PARSE: Found REJECTION keyword.`); return REJECTED_STATUS; }  if (DEBUG_MODE) Logger.log("[DEBUG] STATUS_PARSE: No status keywords found in body.");  return null;}
function applyFinalLabels(processedThreadOutcomes, processingLabel, processedLabel, manualReviewLabel) { /* ... Your full code ... */  const threadIdsToLabel = Object.keys(processedThreadOutcomes);  if (threadIdsToLabel.length === 0) { Logger.log("[INFO] LABEL_MGMT: No thread outcomes to process for labeling."); return; }  Logger.log(`[INFO] LABEL_MGMT: Starting label application based on ${threadIdsToLabel.length} thread outcomes.`);  let successCount = 0; let errorCount = 0;  if (!processingLabel || typeof processingLabel.getName !== 'function') { Logger.log(`[ERROR] LABEL_MGMT: Invalid 'processingLabel' object passed. Expected label name like: ${GMAIL_LABEL_TO_PROCESS}. Aborting labeling.`); return; }  if (!processedLabel || typeof processedLabel.getName !== 'function') { Logger.log(`[ERROR] LABEL_MGMT: Invalid 'processedLabel' object passed. Expected label name like: ${GMAIL_LABEL_APPLIED_AFTER_PROCESSING}. Aborting labeling.`); return; }  if (!manualReviewLabel || typeof manualReviewLabel.getName !== 'function') { Logger.log(`[ERROR] LABEL_MGMT: Invalid 'manualReviewLabel' object passed. Expected label name like: ${GMAIL_LABEL_MANUAL_REVIEW}. Aborting labeling.`); return; }  const processingLabelName = processingLabel.getName();   const processedLabelName = processedLabel.getName();   const manualReviewLabelName = manualReviewLabel.getName();   for (const threadId of threadIdsToLabel) {    const outcome = processedThreadOutcomes[threadId];    const targetLabelObject = (outcome === 'manual') ? manualReviewLabel : processedLabel;    const targetLabelName = targetLabelObject.getName();     try {        const thread = GmailApp.getThreadById(threadId);        if (!thread) { Logger.log(`[WARN] LABEL_MGMT: Thread ${threadId} not found. Skipping.`); continue; }        const currentLabels = thread.getLabels().map(l => l.getName());        if (currentLabels.includes(processingLabelName)) {            try {                thread.removeLabel(processingLabel);                 if (DEBUG_MODE) Logger.log(`[DEBUG]  -> Removed label "${processingLabelName}" from Thread ${threadId}`);                Utilities.sleep(150);             } catch (e) { Logger.log(`[WARN] LABEL_MGMT: Failed to remove label "${processingLabelName}" from Thread ${threadId}: ${e}`); }        }        if (!currentLabels.includes(targetLabelName)) {             try {                thread.addLabel(targetLabelObject);                 Logger.log(`[INFO] LABEL_MGMT: Added label "${targetLabelName}" to Thread ${threadId}`);                Utilities.sleep(150);             } catch(e) { Logger.log(`[ERROR] LABEL_MGMT: Failed to add target label "${targetLabelName}" to Thread ${threadId}: ${e}`); errorCount++; continue; }        } else { if (DEBUG_MODE) Logger.log(`[DEBUG] LABEL_MGMT: Thread ${threadId} already has target label "${targetLabelName}".`); }         successCount++;    } catch (e) { Logger.log(`[ERROR] LABEL_MGMT: Processing labels for Thread ${threadId} (Outer Try/Catch): ${e}`); errorCount++; }    Utilities.sleep(250);  }  Logger.log(`[INFO] LABEL_MGMT: Finished applying labels. Success/Verified: ${successCount}. Errors: ${errorCount}.`);}
function performProcessConsolidation() { /* ... Your placeholder function ... */  Logger.log("[INFO] CONSOLIDATION: Starting step...");  if (DEBUG_MODE) { Logger.log("[DEBUG] CONSOLIDATION: Placeholder only."); }  Logger.log("[INFO] CONSOLIDATION: Finished step.");}

// --- Main Email Processing Function ---
function processJobApplicationEmails() { /* ... Your full code from previous message ... */ const SCRIPT_START_TIME = new Date(); Logger.log(`\n==== STARTING PROCESS JOB EMAILS (${SCRIPT_START_TIME.toLocaleString()}) ====`); Logger.log("[INFO] PROCESS_EMAIL: Accessing Spreadsheet & ensuring tab/formatting..."); const { spreadsheet: ss, sheet: sheet } = getOrCreateSpreadsheetAndSheet(); if (!ss || !sheet) { Logger.log(`[FATAL ERROR] PROCESS_EMAIL: Could not access Sheet/Tab. Aborting.`); return; } Logger.log(`[INFO] PROCESS_EMAIL: Access OK: "${ss.getName()}" / "${sheet.getName()}"`); Logger.log("[INFO] PROCESS_EMAIL: Verifying essential Gmail labels exist..."); let procLbl, doneLbl, manualLbl; try { procLbl = GmailApp.getUserLabelByName(GMAIL_LABEL_TO_PROCESS); doneLbl = GmailApp.getUserLabelByName(GMAIL_LABEL_APPLIED_AFTER_PROCESSING); manualLbl = GmailApp.getUserLabelByName(GMAIL_LABEL_MANUAL_REVIEW); if (!procLbl || !doneLbl || !manualLbl) throw new Error("Labels missing"); if (DEBUG_MODE) Logger.log(`[DEBUG] PROCESS_EMAIL: Labels OK`); } catch(e) { const errorMsg = `Labels missing! Run "0. Initial Setup" first.`; Logger.log(`[FATAL ERROR] PROCESS_EMAIL: ${errorMsg}. Error: ${e.message}`); try { SpreadsheetApp.getUi().alert("Labels Missing", errorMsg, SpreadsheetApp.getUi().ButtonSet.OK); } catch (uiError) { } return; } const lastR = sheet.getLastRow(); const existD = {}; const existIds = new Set(); if (lastR >= 2) { Logger.log(`[INFO] PRELOAD: Loading existing data from Sheet "${sheet.getName()}" Row 2 to ${lastR}...`);  try {    const colsToPreload = [COMPANY_COL, JOB_TITLE_COL, EMAIL_ID_COL];    const startCol = Math.min(...colsToPreload); const endCol = Math.max(...colsToPreload); const numColsToRead = endCol - startCol + 1;    if (numColsToRead < 1 || startCol < 1) throw new Error("Invalid column calculation for preloading.");    const preloadRange = sheet.getRange(2, startCol, lastR - 1, numColsToRead);     const preloadValues = preloadRange.getValues();    const companyIndexInPreload = COMPANY_COL - startCol; const titleIndexInPreload = JOB_TITLE_COL - startCol; const emailIdIndexInPreload = EMAIL_ID_COL - startCol;    for (let i = 0; i < preloadValues.length; i++) { const rowNum = i + 2; const rowData = preloadValues[i]; const emailId = rowData[emailIdIndexInPreload]?.toString().trim() || ""; const originalCompany = rowData[companyIndexInPreload]?.toString().trim() || ""; const originalTitle = rowData[titleIndexInPreload]?.toString().trim() || ""; const companyLower = originalCompany.toLowerCase(); if (emailId) existIds.add(emailId); if (companyLower && companyLower !== 'n/a' && companyLower !== MANUAL_REVIEW_NEEDED.toLowerCase()) { if (!existD[companyLower]) existD[companyLower] = []; existD[companyLower].push({ row: rowNum, emailId: emailId, company: originalCompany, title: originalTitle }); } }    Logger.log(`[INFO] PRELOAD: Complete. Cached ${Object.keys(existD).length} company lookups, ${existIds.size} processed email IDs known.`);  } catch (e) { Logger.log(`[FATAL ERROR] During Data Preload from "${sheet.getName()}": ${e}\nStack: ${e.stack}\nAborting.`); try { SpreadsheetApp.getUi().alert(`Script Error: Failed to preload data. Check Logs. Error: ${e.message}`); } catch (uiError) { Logger.log('[WARN] UI alert failed for preload error.')} return; }} else { Logger.log(`[INFO] PRELOAD: Sheet "${sheet.getName()}" empty/header only.`); } if (DEBUG_MODE) Logger.log(`[DEBUG] GATHER: Fetching threads with label "${procLbl.getName()}"...`); let threads = []; try { threads = procLbl.getThreads(); } catch (e) { Logger.log(`[ERROR] GATHER: Failed getThreads: ${e}`); return; } const msgToSort = []; let skippedCount = 0; let fetchErrorCount = 0; if (DEBUG_MODE) Logger.log(`[DEBUG] GATHER: Found ${threads.length} threads under "${procLbl.getName()}". Fetching messages and checking against processed IDs...`);    for (const thread of threads) { const threadId = thread.getId(); try { const messages = thread.getMessages(); for (const msg of messages) { const msgId = msg.getId(); if (!existIds.has(msgId)) { msgToSort.push({ message: msg, date: msg.getDate(), threadId: threadId }); } else { skippedCount++; } } } catch (e) { Logger.log(`[ERROR] Fetching messages for Thread ${threadId}: ${e}`); fetchErrorCount++; } }    Logger.log(`[INFO] GATHER: Complete. New: ${msgToSort.length}. Skipped: ${skippedCount}. Fetch errors: ${fetchErrorCount}.`);    if (msgToSort.length === 0) {        Logger.log("[INFO] PROCESS: No new messages found.");        let staleLabelOutcomes = {};        const processingLabelName = procLbl.getName();         threads.forEach(th => {            try {                if (th.getLabels().some(l => l.getName() === processingLabelName)) {                    staleLabelOutcomes[th.getId()] = 'done';                     if (DEBUG_MODE) Logger.log(`[DEBUG]  -> Cleanup thread ${th.getId()} still marked "${processingLabelName}".`);                 }            } catch (e) { Logger.log(`[WARN] Cleanup check label error ${th.getId()}: ${e}`);}         });         if (Object.keys(staleLabelOutcomes).length > 0) {             Logger.log(`[INFO] FINISH: Cleaning up ${Object.keys(staleLabelOutcomes).length} old threads...`);             applyFinalLabels(staleLabelOutcomes, procLbl, doneLbl, manualLbl);          } else { Logger.log("[INFO] FINISH: No new messages & no cleanup needed."); }         const SCRIPT_END_TIME_NO_MSG = new Date(); Logger.log(`==== SCRIPT EXECUTION FINISHED (${SCRIPT_END_TIME_NO_MSG.toLocaleString()}) ====`); return;     }    msgToSort.sort((a, b) => a.date - b.date);     Logger.log(`[INFO] PROCESS: Sorted ${msgToSort.length}. Starting processing loop...`); let threadOutcomes = {}; let procCount = 0; let updateCount = 0; let newCount = 0; let errorCount = 0; for (let i = 0; i < msgToSort.length; i++) { const entry = msgToSort[i];        const { message, date: emailDate, threadId } = entry;         const msgId = message.getId();        const processingStartTime = new Date();        if (DEBUG_MODE) Logger.log(`\n--- Processing Msg ${i + 1}/${msgToSort.length} (ID: ${msgId}, Thread: ${threadId}) ---`);        let needsManualReviewDueToParsing = false; let finalStatusFromBody = null; let sheetWriteSuccessful = false; let plainBody = null;        try {            const emailSubj = message.getSubject() || "";            const sender = message.getFrom() || "";            const emailLnk = `https://mail.google.com/mail/u/0/#inbox/${msgId}`;            const processedTimestamp = new Date();            let plat = DEFAULT_PLATFORM;            try { const emailMatch = sender.match(/<([^>]+)>/); if (emailMatch && emailMatch[1]) { const emailAddress = emailMatch[1]; const domainParts = emailAddress.split('@'); if (domainParts.length === 2) { const domain = domainParts[1].toLowerCase(); const domainWords = domain.replace(/[^a-z0-9]+/gi, ' ').replace(/\s+/g, ' ').trim().split(' '); const filteredDomainWords = domainWords.filter(word => word.length > 0); for (const keyword in PLATFORM_DOMAIN_KEYWORDS) { if (filteredDomainWords.includes(keyword)) { plat = PLATFORM_DOMAIN_KEYWORDS[keyword]; if (DEBUG_MODE) Logger.log(`[DEBUG]  -> Platform detected: ${plat}`); break; } } } } } catch (e) { Logger.log(`[WARN] Platform detect error: ${e}`); }            if (DEBUG_MODE) Logger.log(`[DEBUG] Platform final: ${plat}`);             try {                 plainBody = message.getPlainBody();                  if (DEBUG_MODE) Logger.log(`[DEBUG] Got Plain Body (Len: ${plainBody ? plainBody.length : 'null'}).`);            } catch (e) { Logger.log(`[WARN] Get body fail Msg ${msgId}: ${e}`); plainBody = null; }            const extracted = extractCompanyAndTitle(message, plat, emailSubj, plainBody);            let company = extracted.company; let title = extracted.title;            needsManualReviewDueToParsing = (company === MANUAL_REVIEW_NEEDED || title === MANUAL_REVIEW_NEEDED);            if (needsManualReviewDueToParsing && DEBUG_MODE) { Logger.log("[DEBUG]  -> Parsing needs manual review."); }            finalStatusFromBody = parseBodyForStatus(plainBody);             if (DEBUG_MODE) Logger.log(`[DEBUG] Body Status: ${finalStatusFromBody || 'None'}`);            const lookupKey = company.toLowerCase(); let existingRowData = null; let targetRow = -1;            if (company !== MANUAL_REVIEW_NEEDED && existD[lookupKey]) { const matches = existD[lookupKey]; existingRowData = matches.reduce((latest, current) => (current.row > latest.row ? current : latest), matches[0]); targetRow = existingRowData.row; if (DEBUG_MODE) Logger.log(`[DEBUG]  -> Found existing Row ${targetRow} for "${company}".`); }            else { if (DEBUG_MODE) Logger.log(`[DEBUG]  -> No existing row for "${company}". NEW.`); }            if (targetRow !== -1 && existingRowData) {                 try { const rangeToUpdate = sheet.getRange(targetRow, 1, 1, TOTAL_COLUMNS_IN_SHEET);                     const currentValues = rangeToUpdate.getValues()[0]; let updated = false; let finalCompany = (company === MANUAL_REVIEW_NEEDED && existingRowData.company && existingRowData.company !== MANUAL_REVIEW_NEEDED && existingRowData.company !== "N/A")? existingRowData.company : company; let finalTitle = (title === MANUAL_REVIEW_NEEDED && existingRowData.title && existingRowData.title !== MANUAL_REVIEW_NEEDED && existingRowData.title !== "N/A")? existingRowData.title : title; let newValues = [...currentValues];                     if (STATUS_COL > 0 && finalStatusFromBody && finalStatusFromBody !== newValues[STATUS_COL - 1]) { newValues[STATUS_COL - 1] = finalStatusFromBody; updated = true; if (DEBUG_MODE) Logger.log(`[DEBUG]     -> Update Status: ${finalStatusFromBody}`); } if (COMPANY_COL > 0 && finalCompany !== newValues[COMPANY_COL - 1]) { newValues[COMPANY_COL - 1] = finalCompany; updated = true; if (DEBUG_MODE) Logger.log(`[DEBUG]     -> Update Company: ${finalCompany}`); } if (JOB_TITLE_COL > 0 && finalTitle !== newValues[JOB_TITLE_COL - 1]) { newValues[JOB_TITLE_COL - 1] = finalTitle; updated = true; if (DEBUG_MODE) Logger.log(`[DEBUG]     -> Update Title: ${finalTitle}`); } if (PLATFORM_COL > 0 && plat !== newValues[PLATFORM_COL - 1]) { newValues[PLATFORM_COL - 1] = plat; updated = true; if (DEBUG_MODE) Logger.log(`[DEBUG]     -> Update Platform: ${plat}`); }                     if (EMAIL_DATE_COL > 0)         newValues[EMAIL_DATE_COL - 1]         = emailDate;                      if (LAST_UPDATE_DATE_COL > 0)   newValues[LAST_UPDATE_DATE_COL - 1]   = emailDate;                      if (EMAIL_SUBJECT_COL > 0)      newValues[EMAIL_SUBJECT_COL - 1]      = emailSubj;                      if (EMAIL_LINK_COL > 0)         newValues[EMAIL_LINK_COL - 1]         = emailLnk;                      if (EMAIL_ID_COL > 0)           newValues[EMAIL_ID_COL - 1]           = msgId;                      if (PROCESSED_TIMESTAMP_COL > 0) newValues[PROCESSED_TIMESTAMP_COL - 1] = processedTimestamp;                      updated = true;                      if (updated) { rangeToUpdate.setValues([newValues]); Logger.log(`[INFO]    -> SHEET WRITE: Update Row ${targetRow} in "${sheet.getName()}".`); updateCount++; sheetWriteSuccessful = true; existD[lookupKey] = existD[lookupKey].map(entry => entry.row === targetRow ? { row: targetRow, emailId: msgId, company: finalCompany, title: finalTitle } : entry);  }                     else { if (DEBUG_MODE) Logger.log(`[DEBUG]    -> SHEET WRITE: No significant changes detected Row ${targetRow}. Skip write.`); sheetWriteSuccessful = true;   }                } catch (e) { Logger.log(`[ERROR] Update Row ${targetRow} error: ${e}\n${e.stack}`); sheetWriteSuccessful = false; }            } else {                 const initialStatus = finalStatusFromBody || DEFAULT_STATUS;                if (DEBUG_MODE) Logger.log(`[DEBUG]    -> Creating new row data. Status: ${initialStatus}`);                try { const newRowData = new Array(TOTAL_COLUMNS_IN_SHEET).fill("");                     if (PROCESSED_TIMESTAMP_COL > 0) newRowData[PROCESSED_TIMESTAMP_COL - 1] = processedTimestamp; if (EMAIL_DATE_COL > 0) newRowData[EMAIL_DATE_COL - 1] = emailDate; if (PLATFORM_COL > 0) newRowData[PLATFORM_COL - 1] = plat; if (COMPANY_COL > 0) newRowData[COMPANY_COL - 1] = company; if (JOB_TITLE_COL > 0) newRowData[JOB_TITLE_COL - 1] = title; if (STATUS_COL > 0) newRowData[STATUS_COL - 1] = initialStatus; if (LAST_UPDATE_DATE_COL > 0) newRowData[LAST_UPDATE_DATE_COL - 1] = emailDate; if (EMAIL_SUBJECT_COL > 0) newRowData[EMAIL_SUBJECT_COL - 1] = emailSubj; if (EMAIL_LINK_COL > 0) newRowData[EMAIL_LINK_COL - 1] = emailLnk; if (EMAIL_ID_COL > 0) newRowData[EMAIL_ID_COL - 1] = msgId;                     sheet.appendRow(newRowData);                      const newRowNum = sheet.getLastRow();                     Logger.log(`[INFO]    -> SHEET WRITE: Appended Row ${newRowNum} to "${sheet.getName()}".`);                     newCount++; sheetWriteSuccessful = true;                     const newCacheKey = company.toLowerCase(); if (company !== MANUAL_REVIEW_NEEDED && newCacheKey !== 'n/a') { if (!existD[newCacheKey]) existD[newCacheKey] = []; existD[newCacheKey].push({ row: newRowNum, emailId: msgId, company: company, title: title }); }                 } catch (e) { Logger.log(`[ERROR] Append row error: ${e}\n${e.stack}`); sheetWriteSuccessful = false; }            }             if (sheetWriteSuccessful) {                 procCount++; existIds.add(msgId);                  let currentMsgOutcome = (needsManualReviewDueToParsing) ? 'manual' : 'done';                 if (threadOutcomes[threadId] !== 'manual') {                    threadOutcomes[threadId] = currentMsgOutcome;                 }                 if (DEBUG_MODE) Logger.log(`[DEBUG]  -> Message OK. Thread outcome: ${threadOutcomes[threadId]}.`);            }            else {                errorCount++;                threadOutcomes[threadId] = 'manual';                 Logger.log(`[ERROR]  -> Message FAILED (Sheet Write). Thread marked manual.`);            }        } catch (e) {            Logger.log(`[FATAL ERROR] Processing Message ${msgId} error: ${e}\n${e.stack}`);            threadOutcomes[threadId] = 'manual';             errorCount++;         }         if (DEBUG_MODE) { const processingEndTime = new Date(); Logger.log(`--- End Msg ${i + 1}/${msgToSort.length} --- Time: ${(processingEndTime-processingStartTime)/1000}s ---`); }         Utilities.sleep(150); } Logger.log(`\n[INFO] PROCESS: Loop Finished.`); Logger.log(`[INFO] SUMMARY: Processed:${procCount}, Updates:${updateCount}, New:${newCount}, Errors:${errorCount}.`); if (DEBUG_MODE) Logger.log(`[DEBUG] Final Thread Outcomes: ${JSON.stringify(threadOutcomes)}`); if (procLbl && doneLbl && manualLbl) { applyFinalLabels(threadOutcomes, procLbl, doneLbl, manualLbl); } else { Logger.log("[ERROR] Label Apply SKIPPED - Label objects invalid."); } try { performProcessConsolidation(); } catch (e) { Logger.log(`[ERROR] Consolidation step failed: ${e}`); } const SCRIPT_END_TIME = new Date(); Logger.log(`\n==== SCRIPT EXECUTION FINISHED (${SCRIPT_END_TIME.toLocaleString()}) === Time Elapsed: ${(SCRIPT_END_TIME - SCRIPT_START_TIME)/1000}s ====`);}

// --- INTEGRATED: Auto-Reject Stale Applications Function ---
function markStaleApplicationsAsRejected() { const S_START = new Date(); Logger.log(`==== AUTO-REJECT STALE START (${S_START.toLocaleString()}) ====`); const { spreadsheet: ss, sheet: sh } = getOrCreateSpreadsheetAndSheet(); if (!ss || !sh) { Logger.log(`[FATAL] AUTO-REJECT: No Sheet/Tab. Aborting.`); return; } Logger.log(`[INFO] AUTO-REJECT: Using sheet "${sh.getName()}" in "${ss.getName()}".`); const range = sh.getDataRange(); const values = range.getValues(); if (values.length <= 1) { Logger.log("[INFO] AUTO-REJECT: No data beyond header."); return; } const threshold = new Date(); threshold.setDate(threshold.getDate() - (WEEKS_THRESHOLD * 7)); Logger.log(`[INFO] AUTO-REJECT: Stale threshold date: ${threshold.toLocaleDateString()}`); let updatedCt = 0; for (let i=1; i < values.length; i++) { const stat = values[i][STATUS_COL-1]; const updDt = values[i][LAST_UPDATE_DATE_COL-1]; if (!updDt || !(updDt instanceof Date)) { if (DEBUG_MODE && updDt) Logger.log(`[DEBUG] AutoReject Row ${i+1} Skip: Bad Date: ${updDt}`); continue; } if (FINAL_STATUSES_FOR_STALE_CHECK.has(stat)) { if (DEBUG_MODE) Logger.log(`[DEBUG] AutoReject Row ${i+1} Skip: Final Status "${stat}"`); continue; } if (updDt < threshold) { Logger.log(`[INFO] AutoReject Row ${i+1}: Update. LastUpd:${updDt.toLocaleDateString()}, Status:"${stat}" -> "${REJECTED_STATUS}"`); values[i][STATUS_COL-1] = REJECTED_STATUS; updatedCt++; } } if (updatedCt > 0) { Logger.log(`[INFO] AUTO-REJECT: Writing ${updatedCt} updates...`); try { range.setValues(values); Logger.log(`[INFO] AUTO-REJECT: ${updatedCt} stale apps updated.`); } catch (e) { Logger.log(`[ERROR] AUTO-REJECT: Write fail: ${e}\n${e.stack}`); } } else { Logger.log("[INFO] AUTO-REJECT: No stale apps found."); } const S_END = new Date(); Logger.log(`==== AUTO-REJECT STALE END (${S_END.toLocaleString()}) ==== Time: ${(S_END-S_START)/1000}s ====`); }

// --- Menu Function ---
function onOpen() { try { SpreadsheetApp.getUi().createMenu('Job Tracker Tools').addItem('0. Initial Setup (Labels, Sheet, Triggers)', 'initialSetup_LabelsAndSheet').addSeparator().addItem('1. Process New Emails Now', 'processJobApplicationEmails').addItem('2. Mark Stale Apps Rejected', 'markStaleApplicationsAsRejected').addSeparator().addItem('3. Setup/Verify Email Processor Trigger (Hourly)', 'createTimeDrivenTrigger').addItem('4. Setup/Verify Stale Check Trigger (Daily)', 'createOrVerifyStaleRejectTrigger').addToUi(); if(DEBUG_MODE)Logger.log("[DEBUG] Menu created."); } catch(e){ Logger.log(`[ERROR] Menu create fail: ${e}`);}}
